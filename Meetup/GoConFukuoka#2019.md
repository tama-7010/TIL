# GoでCLIツールを作る
## シンプルな機能で実装する
## コマンドは組み合わせて使われる
- ワンライナーでひとまとめに
- スクリプトでひとまとめに
## 標準出力と標準エラーを意識する
- 出力先が同じなので意識されにくい！
- リダイレクトによって出力先は変えることができる→意識しないと後々困る
- os.Stdout / os.Stderr
## マルチプラットフォームを意識する
- 改行コード...Unix: \n Windows: \r\n
- ファイルのセパレータ...filepathパッケージで吸収してくれる
-- pathパッケージはURL用
## 終了ステータス
- 目に見えないためおろそかにされやすい
- スクリプト内にて終了ステータスによって分岐したりする
- Exit()関数煮て、引数で終了ステータスを出力する
## 外部リソースは明示的に解放する
- Close()メソッドを呼び出す
- Close()メソッドはdeferで呼び出す
- Flush()メソッドがともなうClose()メソッドはdeferなしで呼び出す
## ファイルの階層
## 使われどころを意識する
- goroutineから呼ばれるケース
- パッケージ内でexitされると、パッケージ利用者はどうすることもできない

# Goでコマンドラインを量産する
## ツールを配布する
- OSSを頒布するうえで気をつけること
-- LICENSE、同梱ライブラリのLICENSE、README、スタンダードライブラリのLICENSE
## 最近の雛形
### mainパッケージをどこに置くか
- レポジトリ直下派
- ./cmd/myapp/ 派
### main.main()はボイラープレートのみ
- os.Exitするのはボイラープレートのみ
### コマンドラッパーを書くということ
- コマンドを起動する exec.CommandContext
- golang.org/x/text/transform.Transformer
- コマンドに情報を渡す: 環境変数exec.Command(...).Env = append(os.Environ(), "key=val")
#### 大きい情報を共有するためには
- 一時ファイル経由
- 標準入力にパイプで書き込む
- ExtraFilesによるファイルディスクリプタ渡し
- ソケット経由
### コマンドを停止する
#### killコマンド...プロセスにシグナルを送る
- シグナルハンドリング...プロセスはシグナルをトラップし、ハンドリングすることができる
- exec.CommandContext...SIGKILLで強制終了いている


# Goの画像処理はポテンシャルがある
## 画像処理の基礎
### image.Imageインターフェース
* 画像の領域、画素数、カラーモード
* 画像の処理は1pxごとに処理していくことが鉄板
* Average Hashアルゴリズム
* 画像処理アルゴリズムに要求される値をImageインターフェースから取得し、適用する
### drawパッケージ
* 画像を重ねる時に使う

## Go + OpenCV
### GoCVパッケージ
* 輪郭を切り取るマスクを作るためにOpenCVを使う

## 画像処理のテストの書き方
* RGBAを1pxごとに検査している
* 時間がかかりすぎるので、最初に1pxだけテストしているものもある
* 画像処理のテストでは速度を取るか精度を取るかで二律背反になる

## GoはWeb Assemblyに対応しているのでWeb上で動かすことができる

# メールサーバのホスティング
## ホスティング…複数のユーザーが使用できるサーバ

# Chrome as a seviceとGo
## 審査項目としてあるPDFの取得が必要->時間がかかる
## Puppeteer…Chrome DevTool Protocol ブラウザを自動操作するNode.jsライブラリ
## パフォーマンスの改善
### トレースやプロファイラに注目する


# FTPとGo言語
## 負荷テストをすればLeak発生がわかりやすい 


# Go Unit Test
## Cost-Effective Unit Test
### 適切なエラーレポート
* 直接的かつ適切なエラーレポートを行う f(x) = y, want = z
### 適切なエラーハンドリング
* 致命的なエラーでなければ強制終了すべきでない t.Errorfでハンドリングする
### テーブル駆動テスト
* Golden拡張子
### 

# Goでファミコンエミュレータを実装する

